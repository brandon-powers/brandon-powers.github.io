---
title: Brandon Powers | Projects
layout: default
permalink: /projects
---

<section class="list-header">

    <h2>Projects</h2>
    <div class="divider-line"></div>

</section>

<section class="list-items">

    <div class="project">
        <a name="pasCal" href="#"></a>
        <h3>pasCal</h3>
        <p class="skills">C, gdb, valgrind</p>
        <p><strong>pasCal</strong> is a partial implementation of a subset of the Pascal programming language in C. It performs the following stages of analysis on the source code: lexical, syntax, and semantic. It's a one-pass implementation, in that the source is only scanned once and the analysis stages are all done around the same time, as opposed to sequentially and making multiple passes.</p>
        <p><strong>Lexical analysis</strong> was done by simulating the computation of a non-deterministic finite automaton (NFA) by using it's transition table to produce an output stream of tokens, given the original source as input. Along with the source code for the lexer, the NFA used is also viewable using a program called <a href="http://www.jflap.org/" target="_blank">JFLAP</a>.</p>
        <p>The next step in the process was <strong>syntax and semantic analysis</strong>, which were both done in the parser. The context-free grammar (CFG) representing the syntax of Pascal was parsed using a recursive descent parser, where there was one function per non-terminal symbol. This created an abstract syntax tree (AST) where the source of the program was generated through the CFG, and if an error occured, it was reported to stdout. During the parsing, the semantic analysis was done with two main parts: scope and type. To deal with scope, a scope level was assigned to each symbol added to the symbol table, and made sure to use the correct level of scope when dealing with any particular symbol. To deal with type, type attribtues were added to each symbol in the symbol table, partially assigned using a C struct representing the semantics of one or many symbols.</p>
        <p><strong><a href="https://github.com/brandon-powers/pasCal" target="_blank">Source Code</a></strong></p>
    </div>

    <div class="project">
        <a name="pshare" href="#"></a>
        <h3>pshare</h3>
        <p class="skills">Python, argparse, API wrappers (tweepy + facepy)</p>
        <p><strong>pshare</strong> is a python CLI for social media sharing (on Twitter and Facebook). The goal of pshare was to allow someone to do something as simple as post a blog post to multiple social media platforms in a single line command (psh -tf post ...) from the terminal. It's intuitive and easy to use. The commands pshare implements are the basic commands of any platform: read, post, and delete.</p>
        <p><strong><a href="https://github.com/mgzwarrior/pshare" target="_blank">Source Code</a></strong></p>
    </div>

    <div class="project">
        <a name="pyrd" href="#"></a>
        <h3>pyrd</h3>
        <p class="skills">Python, BeautifulSoup</p>
        <p><strong>pyrd</strong> is a multi-threaded python-reddit (pyrd) web scraping search tool. The idea behind pyrd was to make a command-line application that allows a user to search multiple subreddits for posts, given a list of keywords. This was to be done through web scraping with BeautifulSoup, as opposed to using Reddit's API mainly for learning purposes, yet the utility still stands.</p>
        <p><strong><a href="https://github.com/brandon-powers/pyrd" target="_blank">Source Code</a></strong></p>
    </div>

    <div class="project">
        <a name="ftp" href="#"></a>
        <h3>simple-ftp</h3>
        <p class="skills">C++, gdb, valgrind</p>
        <p>I call this project 'simple-ftp' because it's an <strong>implementation of a simple file transfer protocol</strong>, supporting commands like get, put, and delete. First, I created the protocol used for the transfer of files and commands in a text file, then implemented them in C++. </p>
        <p>This project was important for me because it allowed me to take it through the many stages of software development. It went from a <em>problem specification</em>, to a <em>design</em> of a solution and protocol, to the <em>implementation</em> of that solution. It made me think about tradeoffs of doing one thing over the other, and the effect it would have on the final project. I also had to use the utilities <strong>gdb</strong> and <strong>valgrind</strong>; gdb for debugging + segmentation faults and valgrind for memory leaks.</p>
        <p>On a final note, if you're interested in using this application, the client is compatible on both a Linux and OS X system, while the server is only compatible on a Linux system.</p>
        <p><strong><a href="https://github.com/brandon-powers/simple-ftp" target="_blank">Source Code</a></strong></p>
    </div>

    <div class="project">
        <a name="personal-website" href="#"></a>
        <h3>brandon-powers.github.io</h3>
        <p class="skills">HTML, CSS, Jekyll, GitHub Pages</p>
        <p>This website was created with the goal of being <strong>as simple as possible</strong>. For that reason, I used HTML and CSS to write the markup and Jekyll to build the site. I found Jekyll to be such a useful tool in that it gives you clean URL's, includes, Liquid template processing, etc. all with the performance benefits of static content with no backend. Lastly, I'm hosting this website on GitHub Pages with <em>enforced https</em>, which is really awesome.</p>
        <p><strong><a href="https://github.com/brandon-powers/brandon-powers.github.io" target="_blank">Source Code</a></strong></p> 
    </div>

</section>
